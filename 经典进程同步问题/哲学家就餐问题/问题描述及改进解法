有五个哲学家，他们的生活方式是交替地进行思考和进餐。他们共用一张圆桌，分别坐在五张椅子上。在圆桌上有五个碗和五支筷子，平时一个哲学家
进行思考，饥饿时便试图取用其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐。进餐完毕，放下筷子又继续思考。

哲学家进餐问题可看作是并发进程并发执行时处理共享资源的一个有代表性的问题。


初始解法：
Var chopsitck:array[0,1,2,3,4] of semaphore=1;
/*5支筷子分别设置为初始值为1的互斥信号量*/
第i个哲学家的活动
repeat
  wait(chopstick[i]);
  wait(chopstick[(i+1)%5]);
        eat();
  signal(chopstick[i]);
  signal(chopstick[(i+1)%5]);
        think();
until false;

此算法可以保证不会有相邻的两位哲学家同时进餐。若五位哲学家同时饥饿而各自拿起了左边的筷子，这使五个信号量chopstick 均为 0，当他们试图去
拿起右边的筷子时，都将因无筷子而无限期地等待下去，即可能会引起死锁。


改进解法：
方法一：至多只允许四位哲学家同时去拿左筷子，最终能保证至少有一位哲学家能进餐，并在用完后释放两只筷子供他人使用。

方法二：仅当哲学家的左右手筷子都拿起时才允许进餐。

方法三：规定奇数号哲学家先拿左筷子再拿右筷子，而偶数号哲学家相反。
